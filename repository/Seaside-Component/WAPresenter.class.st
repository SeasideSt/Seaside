"
WAPresenter holds the functionality that is common to WAComponent and WADecoration. Subclasses of this class may have state and can be stored in instance variables of other Presenters.

You might want to subclass WAPresenter if you do not need the special abilities (decoration and call/answer) of WAComponent but do need one or more of the following:

	+ The ability to specify objects whose state should be backtracked (#states)
	+ The ability to provide CSS and JavaScript for the component (#style, #script)
	+ The ability to ""embed"" other persistent Presenters within this one (#children)

WAPresenter does not support call/answer or the addition of Decorations. If you need either of these features, you should subclass WAComponent instead.

Child Presenters:
It is common for a Presenter to display instances of other Presenters while rendering itself.  It does this by passing them into the #render: method of a renderer (typically an instance of WACanvas).  For example, this #renderContentOn: method simply renders a heading and then displays a counter component 
immediately below it:

	renderContentOn: html
		html heading level3; with: 'My Counter'.
		html render: myCounter.

It's important that you use #render:, rather than directly calling the #renderContentOn: method of the subcomponent. The following is *not* correct:

	renderContentOn: html
		html heading level3; with: 'My Counter'.
		myCounter renderContentOn: html.   ""DON'T DO THIS"".

These sub-Presenters are usually instance variables of the Presenter that is ""embedding"" them.  They are commonly created as part of the Presenter's #initialize method:

	initialize
		myCounter := WACounter new.

They may also be stored in a collection. One fairly common pattern is to keep a lazily initialized dictionary of sub-presenters that match a collection of model items. For example, if you wanted a BudgetItemRow subcomponent for each member of budgetItems, you might do something like this:

	initialize
		budgetRows := Dictionary new.

	rowForItem: anItem
		^budgetRows at: anItem ifAbsentPut: [ BudgetItemRow item: anItem ].

	renderContentOn: html
		self budgetItems
			do: [ :each | html render: (self rowForItem: each) ]
			separatedBy: [ html horizontalLine ].

Each parent Presenter *must* implement a #children method that returns a collection of all of the sub-Presenters that it might display on the next render. For the above two examples, #children might look like this:

	children
		^Array with: myCounter

or this:

	children
		^self budgetItems collect: [ :each | self rowForItem: each ].
		
Visibility:
A Presenter is visible if it is:
- the root of an application
- a child of a visible Presenter (returned by #children) that has not been #call:'d
"
Class {
	#name : #WAPresenter,
	#superclass : #WAPainter,
	#category : 'Seaside-Component-Base'
}

{ #category : #visiting }
WAPresenter >> accept: aVisitor [
	aVisitor visitPresenter: self
]

{ #category : #convenience }
WAPresenter >> allPresentersDo: aBlock [
	(WAAllPresenterGuide client:
		(WAPluggablePresenterVisitor block: aBlock))
		start: self
]

{ #category : #hooks }
WAPresenter >> children [
	"This method is really important. It should return a collection of all sub-presenters that will (or might) be rendered in #renderContentOn:. Components that are displayed using #call: are *not* children.

	If the contents returned by this method change over time make sure to return them in #states as well, otherwise the back button will fail."

	^ #()
]

{ #category : #iterating }
WAPresenter >> childrenDo: aBlock [
	self children do: [ :each | 
		each == self ifTrue: [
			"fix for http://code.google.com/p/seaside/issues/detail?id=697"
			WAChildComponentShouldNotBeSelfError 
				signal: self class name greaseString, ' >> #children - the returned collection contains a reference to self. Exception raised to avoid infinite recursion.' ].
		each isNil
			ifFalse: [ aBlock value: each ] ]
]

{ #category : #decorations }
WAPresenter >> decoratedComponent [
	"For polymorphism with WADecoration"
	
	^ nil
]

{ #category : #delegation }
WAPresenter >> handleAnswer: anObject [
	^ false
]

{ #category : #hooks }
WAPresenter >> initialRequest: aRequest [
	"When a new session is started, all visible presenters (components or tasks) receive this message with the request as argument.

	A common usage for this is to initialize their state depending on the URL of the request. This is one building block for bookmarkable URL. The other is updateUrl: where you can manipulate the anchor urls generated by Seaside.

	You can not use #call: in here. Consider using a WATask instead and sending #call: in #go.

	See WABrowser for examples.
	You may want to access the WAPathConsumer (self requestContext consumer) to get a hold of the unconsumed path."
]

{ #category : #testing }
WAPresenter >> isDecoration [
	^ false
]

{ #category : #rendering }
WAPresenter >> renderContentOn: aRenderer [
	"By default, render all our children in order. Presenters should override this method
	to specify how they should render themselves. By convention, implementations of this
	method that expect a Canvas renderer use 'html' as the parameter name.
	See also #rendererClass."
	
	self childrenDo: [ :each | aRenderer render: each ]
]

{ #category : #rendering }
WAPresenter >> renderUndecoratedWithContext: aRenderContext [
	"Render ourselves directly on aRenderer without allowing our Decorations to be visited."
	
	self accept: aRenderContext visitor
]

{ #category : #hooks }
WAPresenter >> script [
	"The same as #style except that it is for JavaScript. This is rarely used, consider using WAFileLibrary or exernal files instead."
	^ nil
]

{ #category : #hooks }
WAPresenter >> states [
	"Answer a collection of states that should be backtracked."

	^ #()
]

{ #category : #hooks }
WAPresenter >> style [
	"Returns a CSS stylesheet associated with this component. This stylesheet will be added to <head> section of the html document so it will be global and not scoped.

	This is done for all visible components (see class comment of WAComponent for what visible means).

	Nice for demos but consider using WAFileLibrary or external files instead."

	^ nil
]

{ #category : #updating }
WAPresenter >> updateRoot: anHtmlRoot [
	"This method allows you customize the <head> section of an HTML document. The API is very similar to the 'Canvas API' for rendering in the <body> section (where you 'draw' in #renderContentOn:).

	anHtmlRoot is an instance of WAHtmlRoot

	Whenever you override this method don't forget to send super"
	super updateRoot: anHtmlRoot.

	self style isNil ifFalse: [ anHtmlRoot addStyle: self style ].
	self script isNil ifFalse: [ anHtmlRoot addScript: self script ]
]

{ #category : #updating }
WAPresenter >> updateStates: aSnapshot [
	"This method allows to register objects for backtracking. Don't forget to send super in all cases."

	self states do: [ :each | aSnapshot register: each ]
]

{ #category : #convenience }
WAPresenter >> visiblePresentersDo: aBlock [
	(WAVisiblePresenterGuide client:
		(WAPluggablePresenterVisitor block: aBlock))
		start: self
]
