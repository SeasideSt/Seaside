"
What does FileLibrary do
=============================
It allows to serve static files directly from seaside without the need for a standalone server like Apache or to configure Kom. These files can reference each other (say a CSS references an image) and can be distrubuted the same way as normal Smalltalk code (Monticello, SqueakMap, ...).

Each file in a file library is represented by a method. The method name is created from the file name, the dot is removed and the first letter of the suffix in capitalized. This puts certain limitations to the allowed filenames. Eg. 'main.css' becomes #mainCss.

Like Script- and StyleLibraries FileLibraries can be added to an application so that they automatically include themselves in the document root. Implement #selectorsToInclude and return the selectors you whish to be added to the document root.

How to create a FileLibrary
================================
- First create the static files and put them in some directory. From there they can reference the other files in the same directory normally with their filenames.
- Make sure you have a ""Files"" entry that serves your files. This is a normal entry point type that you can find in your /seaside/config application. If you don't already have one, you can create it if you select ""Files"" in the type field of the ""add entry point"" dialog. For the rest of this text we assume you chose ""files"" as the path.
- Create a subclass of WAFileLibrary, for the rest of this text I assume its name is MyFileLibrary.
- To add the files to your file library there are two ways.
1. Programmatically with MyFileLibrary class >> #addAllFilesIn: / #addFileNamed:. For example MyFileLibrary addAllFilesIn: '/path/to/directory/with/files' or MyFileLibrary addFileNamed: '/path/to/background.png'.
2. Via the web interface. Go to your /seaside/config application and there click configure for your ""Files"". Click ""configure"" behind MyFileLibrary. There you can add a file by uploading it (select the file, then click ""Add"")

Note that a ""Files"" can consist of several file libraries and can even have tradional script or style libraries.

How to integrate a FileLibrary into your application
=============================================================
Files from a FileLibrary are ingetrated the same way other static files are integrated. They have a constant path that is '/seaside/<Static File Library>/<FileLibrary class name>/<filename>' so for example '/seaside/files/MyFileLibrary/background.png'. These can be conveniently generated by 'MyFileLibrary / #aSelector' where #aSelector is the name of the method representing that file. For example 'MyFileLibrary / #backgroundPng'.

How to get back the files in a FileLibrary
=================================================
The contents of a file library can be written out to disk. Writing out a file library first makes a folder with the name of the file library in the folder of your Smallatlk image. Then a file for each file in the file library is created in this folder. Writing out to disk can happen in three ways
1. MyFileLibrary default deployFiles
2. Via the configuration interface of the file library. On the same page where you can add files to your file library there is also a button 'write to disk' which will write out all the files in this library.
3. Via the configuration interface of your application. In the section where you can add libraries to your application there is a a button 'write to disk' which will write out all the libraries of this application.

Examples:
==========

The following code uses WAFileLibrary to add a CSS file to a page.

updateRoot: anHtmlRoot
	super updateRoot: anHtmlRoot.
	anHtmlRoot stylesheet 
		url: WAFileLibraryDemo / #mainCss
		
The folllowing code uses WAFileLibrary to display an image.

renderContentOn: html
	html image
		url: WAFileLibraryDemo / #mainJpg
		

Trouble Shooting:
==========
Earlier versions would create methods without a time stamp. You can fix this by recompiling these methods by adapting the following code

SUAllTestLibrary basicNew in: [ :library |
	#(demologoGif headerGif backgroundGif demoGif logoGif menuGif) do: [ :each |
		library class
			addFileNamed: (library asFilename: each)
			contents: (library perform: each) ] ]
"
Class {
	#name : #WAFileLibrary,
	#superclass : #WAAbstractFileLibrary,
	#category : 'Seaside-Core-Libraries'
}

{ #category : #'file addition' }
WAFileLibrary class >> addFileNamed: aFilename contents: aByteArrayOrString [
	| selector |
	selector := self asSelector: aFilename.
	(self isBinary: aFilename)
		ifTrue: [ self compileBinary: aByteArrayOrString selector: selector ]
		ifFalse: [ self compileText: aByteArrayOrString selector: selector ]
]

{ #category : #'vw port-squeak' }
WAFileLibrary class >> adjustForVisualWorks [
	| newSource oldSource badCode goodCode |
	badCode := 'xxxCache := #(nil).'.
	goodCode := 'xxxCache := #(nil) beMutable.'.
	self selectors do: [ :selector |
		oldSource := self sourceCodeAt: selector.
		(oldSource indexOfSubCollection: badCode startingAt: 1) > 0 ifTrue: [
			newSource := oldSource copyReplaceAll: badCode with: goodCode.
			self compile: newSource classified: self methodCategory ] ]
]

{ #category : #migrating }
WAFileLibrary class >> migrateSubclassesSeaside29 [
	"migrates all subclasses of the receiver to Seaside 2.9
	you should not send this message to WAFileLibrary because that will also migrate the classes in Seaside"
	self allSubclassesDo: [ :each |
		each migrateToSeaside29 ]
]

{ #category : #migrating }
WAFileLibrary class >> migrateToSeaside29 [
	"migrates only the receiver to Seaside 2.9"
	(self default fileSelectors intersection: self selectors) do: [ :each |
		| contents |
		contents := (self default perform: each).
		(contents isKindOf: ByteArray) ifTrue: [
			| file |
			file := WAFile new
				contents: contents;
				fileName: (self default asFilename: each);
				yourself.
			self default addFile: file ] ]
]

{ #category : #convenience }
WAFileLibrary class >> register [
	"no longer needed left in so that code can still be loaded since it is sent in class side initialize methods"
]

{ #category : #convenience }
WAFileLibrary class >> unregister [
	"no longer used"
]

{ #category : #private }
WAFileLibrary >> asFilename: aSelector [ 
	| dotIndex extension |
	dotIndex := self lastUpperCaseIndexIn: aSelector.
	dotIndex = 0 ifTrue: [
		"convert Symbol to String"
		^ aSelector greaseString ].
	extension := (aSelector last: aSelector size - dotIndex + 1) asLowercase.
	^ (aSelector first: dotIndex - 1) , '.' , extension
]

{ #category : #accessing }
WAFileLibrary >> cacheDuration [
	"Answer the duration the response should be cached by the user agent."
	^ self class defaultCacheDuration
]

{ #category : #actions }
WAFileLibrary >> deployFiles [
	"Write to disk the files that the receiver use to serve as methods.
	The files are stored in a subfolder named like the classname of the receiver in a subfolder of Smalltalk image folder."
	GRPlatform current ensureExistenceOfFolder: self name.
	self fileSelectors do: [ :each | 
		GRPlatform current 
			write: (self perform: each)
			toFile: (self asFilename: each)
			inFolder: self name ]
]

{ #category : #accessing }
WAFileLibrary >> documentOf: aSelector [
	^ self perform: aSelector
]

{ #category : #private }
WAFileLibrary >> fileSelectors [
	"deliberately name WAFileLibrary rather than self class"
	^ self fileSelectorsTo: WAFileLibrary
]

{ #category : #accessing }
WAFileLibrary >> fileSizeOf: aSymbol [
	^ (self perform: aSymbol) size
]

{ #category : #handling }
WAFileLibrary >> handle: aRequestContext [
	| fileName selector fileHandler |
	fileName := aRequestContext consumer next.
	selector := self asSelector: fileName.
	(self fileSelectors includes: selector) 
		ifFalse: [ ^ self ].
	
	fileHandler := aRequestContext handler.
	fileHandler useXSendfile
		ifTrue: [
			aRequestContext respond: [ :response |
				response
					cacheFor: self cacheDuration;
					headerAt: 'X-Sendfile' put: (self fullPathForFileName: fileName using: fileHandler);
					contentType: (self mimetypeOf: selector) ] ]
		ifFalse: [
			aRequestContext respond: [ :response |
				response
					cacheFor: self cacheDuration;
					document: (self documentOf: selector)
					mimeType: (self mimetypeOf: selector) ] ]
]

{ #category : #accessing }
WAFileLibrary >> mimetypeForFile: aFilename [
	^ self class mimetypeFor: (aFilename copyAfterLast: $.)

]

{ #category : #accessing }
WAFileLibrary >> mimetypeOf: aSelector [
	^ self mimetypeForFile: (self asFilename: aSelector)
]
